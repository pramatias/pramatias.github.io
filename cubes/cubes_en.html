<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-28 Sun 02:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>The Lowest Level PL</title>
<meta name="author" content="emporas" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">The Lowest Level PL</h1>
<div id="table-of-contents" role="doc-toc">
<h1><a accesskey="H" href="../index.html"> HOME </a></h1><h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org8b7237f">Problem Statement</a></li>
<li><a href="#org0ba6db0">Math</a>
<ul>
<li><a href="#org14253af">Enumeration of placements</a></li>
<li><a href="#org72b2869">Inclusion–exclusion setup</a>
<ul>
<li><a href="#orgb7e5f9a">Total (no restrictions)</a></li>
<li><a href="#org196b0d8">One colour adjacent (e.g. \(A_R\))</a></li>
<li><a href="#orge6b0e17">Two colours adjacent (e.g. \(A_R\cap A_G\))</a></li>
<li><a href="#org92c7ca2">All three colours adjacent (\(A_R\cap A_G\cap A_B\))</a></li>
</ul>
</li>
<li><a href="#org9105297">Put everything together</a></li>
</ul>
</li>
<li><a href="#org2a5a050">Lean</a></li>
<li><a href="#org19a3ee0">Haskell</a></li>
<li><a href="#org66bccab">Rust</a></li>
</ul>
</div>
</div>
<p>
Let&rsquo;s compare the different implementations of a simple problem in three PLs. All three have some common characteristics.
</p>

<ul class="org-ul">
<li>Exhaustive pattern matching</li>
<li>No null/nil</li>
<li>Algeraic data types</li>
</ul>

<p>
The goal is to identify which PL of all is the lowest level.
</p>

<p>
Rust&rsquo;s implementation isn&rsquo;t ideal, but I kept it that way to be as similar as possible to the other implementations. Also Rust doesn&rsquo;t have recursion.
</p>

<p>
The math notation at some places cannot be copied, the renderer doesn&rsquo;t recognize it as a math tex notation. I cannot figure out why, but first time I wrote math using tex.
</p>
<div id="outline-container-org8b7237f" class="outline-2">
<h2 id="org8b7237f">Problem Statement</h2>
<div class="outline-text-2" id="text-org8b7237f">
<p>
<b>6 colored cubes into 9 holes</b>
</p>

<p>
We place six colored cubes — two red (R), two green (G), two blue (B) — into nine labeled holes (positions in a row). The remaining three holes are empty (we denote empty by E or &ldquo;.&rdquo;).
</p>

<p>
Constraint: <b><b>no two adjacent colored cubes of the same color</b></b> may occur. Empty holes may be adjacent to anything (including empties and same-colored neighbors).
</p>

<p>
How many distinct arrangements (sequences of length 9 of the multiset \(\{R^2,G^2,B^2,E^3\}\)) satisfy the adjacency constraint?
</p>
</div>
</div>
<div id="outline-container-org0ba6db0" class="outline-2">
<h2 id="org0ba6db0">Math</h2>
<div class="outline-text-2" id="text-org0ba6db0">
</div>
<div id="outline-container-org14253af" class="outline-3">
<h3 id="org14253af">Enumeration of placements</h3>
<div class="outline-text-3" id="text-org14253af">
<p>
Let the multiset be \(\{R,R,G,G,B,B,E,E,E\}\). Without adjacency restrictions, the number of distinct sequences is the multinomial
\[
N_{\text{total}}=\frac{9!}{2!\,2!\,2!\,3!}.
\]
</p>

<p>
Let for a colour \(X\in\{R,G,B\}\) the event \(A_X\) be ``the two \(X\)-cubes are adjacent somewhere in the sequence.&rsquo;&rsquo; Because each colour appears exactly twice, \(A_X\) is equivalent to the two \(X\)-cubes forming a single adjacent block \(XX\).
</p>

<p>
We want sequences avoiding all three events \(A_R,A_G,A_B\). We will count them by inclusion–exclusion.
</p>
</div>
</div>
<div id="outline-container-org72b2869" class="outline-3">
<h3 id="org72b2869">Inclusion–exclusion setup</h3>
<div class="outline-text-3" id="text-org72b2869">
<p>
By inclusion–exclusion,
</p>

<p>
N<sub>good</sub> = N<sub>total</sub> - &sum;<sub>X</sub> N(A<sub>X</sub>) + &sum;<sub>X&lt;Y</sub> N(A<sub>X&cap;</sub> A<sub>Y</sub>) - N(A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>)
</p>

<p>
N<sub>good</sub> = N<sub>total</sub> - &sum;<sub>X&isin;\{R,G,B\}</sub> N(A<sub>X</sub>) + &sum;<sub>X&lt;Y</sub> N(A<sub>X&cap;</sub> A<sub>Y</sub>) - N(A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>)
</p>

<p>
We compute each term by replacing each adjacent pair \(XX\) by a single block and counting permutations of the resulting multiset.
</p>
</div>
<div id="outline-container-orgb7e5f9a" class="outline-4">
<h4 id="orgb7e5f9a">Total (no restrictions)</h4>
<div class="outline-text-4" id="text-orgb7e5f9a">
<p>
\[
N_{\text{total}}=\frac{9!}{2!\,2!\,2!\,3!}.
\]
</p>

<p>
Compute the factorials and denominators explicitly:
</p>
\begin{align*}
9!&=362\,880,\\
2!\,2!\,2!\,3!&=2\cdot2\cdot2\cdot6=48,\\
N_{\text{total}}&=\frac{362\,880}{48}=7\,560.
\end{align*}
</div>
</div>
<div id="outline-container-org196b0d8" class="outline-4">
<h4 id="org196b0d8">One colour adjacent (e.g. \(A_R\))</h4>
<div class="outline-text-4" id="text-org196b0d8">
<p>
Treat the two \(R\)-cubes as a single block \(RR\). The remaining multiset is \(\{RR, G,G, B,B, E,E,E\}\) of size 8 with multiplicities \(G:2, B:2, E:3\). Thus
\[
N(A_R)=\frac{8!}{2!\,2!\,3!}.
\]
Compute:
</p>
\begin{align*}
8!&=40\,320,\\
2!\,2!\,3!&=2\cdot2\cdot6=24,\\
N(A_R)&=\frac{40\,320}{24}=1\,680.
\end{align*}


<p>
By symmetry the same value holds for \(N(A_G)\) and \(N(A_B)\). Hence
\[
\sum_X N(A_X)=3\cdot1\,680=5\,040.
\]
</p>
</div>
</div>
<div id="outline-container-orge6b0e17" class="outline-4">
<h4 id="orge6b0e17">Two colours adjacent (e.g. \(A_R\cap A_G\))</h4>
<div class="outline-text-4" id="text-orge6b0e17">
<p>
Treat \(RR\) and \(GG\) as two blocks. The remaining multiset is \(\{RR,GG,B,B,E,E,E\}\) of size 7 with multiplicities \(B:2, E:3\). Thus
\[
N(A_R\cap A_G)=\frac{7!}{2!\,3!}.
\]
Compute:
</p>
\begin{align*}
7!&=5\,040,\\
2!\,3!&=2\cdot6=12,\\
N(A_R\cap A_G)&=\frac{5\,040}{12}=420.
\end{align*}


<p>
There are \(\binom{3}{2}=3\) unordered pairs of colours, so
\[
\sum_{X\lt Y} N(A_X\cap A_Y) = 3\cdot420 = 1260.
\]
</p>
</div>
</div>
<div id="outline-container-org92c7ca2" class="outline-4">
<h4 id="org92c7ca2">All three colours adjacent (\(A_R\cap A_G\cap A_B\))</h4>
<div class="outline-text-4" id="text-org92c7ca2">
<p>
Treat \(RR,GG,BB\) as three blocks. The remaining multiset is \(\{RR,GG,BB,E,E,E\}\) of size 6 with multiplicity \(E:3\). Thus
\[
N(A_R\cap A_G\cap A_B)=\frac{6!}{3!}.
\]
Compute:
</p>
\begin{align*}
6!&=720,\\
3!&=6,\\
N(A_R\cap A_G\cap A_B)&=\frac{720}{6}=120.
\end{align*}
</div>
</div>
</div>
<div id="outline-container-org9105297" class="outline-3">
<h3 id="org9105297">Put everything together</h3>
<div class="outline-text-3" id="text-org9105297">
<p>
Apply inclusion–exclusion:
</p>

<p>
N<sub>good</sub>
= N<sub>total</sub> - &sum;<sub>X</sub> N(A<sub>X</sub>) + &sum;<sub>X&lt;Y</sub> N(A<sub>X&cap;</sub> A<sub>Y</sub>) - N(A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>)
= 7560 - 5040 + 1260 - 120 = 3660.
</p>

<p>
Therefore there are \(\boxed{3\,660}\) admissible arrangements.
</p>
</div>
</div>
</div>
<div id="outline-container-org2a5a050" class="outline-2">
<h2 id="org2a5a050">Lean</h2>
<div class="outline-text-2" id="text-org2a5a050">
<div class="org-src-container">
<pre class="src src-haskell">inductive Color where
  | R | G | B | E
  deriving Repr, DecidableEq

structure Counts where
  r : Nat
  g : Nat
  b : Nat
  e : Nat
  deriving Repr

def countsZero (c : Counts) : Bool :=
  c.r == 0 &amp;&amp; c.g == 0 &amp;&amp; c.b == 0 &amp;&amp; c.e == 0

def decCount (c : Counts) (col : Color) : Counts :=
  match col with
  | Color.R =&gt; { c with r := c.r - 1 }
  | Color.G =&gt; { c with g := c.g - 1 }
  | Color.B =&gt; { c with b := c.b - 1 }
  | Color.E =&gt; { c with e := c.e - 1 }

-- allowed choices given remaining counts and previous placed color
def allowed (counts : Counts) (prev : Option Color) : List Color :=
  let ok (col : Color) (avail : Nat) : Bool :=
    avail &gt; 0 &amp;&amp;
    match prev with
    | none =&gt; true
    | some p =&gt; (p != col) || (col == Color.E) -- empties may repeat; colored must differ
  ([Color.R, Color.G, Color.B, Color.E]).filter fun col =&gt;
    match col with
    | Color.R =&gt; ok Color.R counts.r
    | Color.G =&gt; ok Color.G counts.g
    | Color.B =&gt; ok Color.B counts.b
    | Color.E =&gt; ok Color.E counts.e

partial def build (rem : Nat) (prev : Option Color) (counts : Counts) : List (List Color) :=
  if rem == 0 then
    if countsZero counts then [ [] ] else []
  else
    let choices := allowed counts prev
    -- avoid using `List.bind` in case of name-resolution differences;
    -- build result by folding over choices and appending mapped tails
    choices.foldl (fun acc c =&gt;
      let counts' := decCount counts c
      let tails := build (rem - 1) (some c) counts'
      acc ++ (tails.map fun t =&gt; c :: t)
    ) []

def showColor : Color -&gt; String
  | Color.R =&gt; "R"
  | Color.G =&gt; "G"
  | Color.B =&gt; "B"
  | Color.E =&gt; "."

def main : IO Unit := do
  let initial : Counts := { r := 2, g := 2, b := 2, e := 3 }
  let solutions := build 9 none initial
  IO.println s!"Found {solutions.length} solutions (each printed as a 9-length sequence; '.' = empty)"
  for s in solutions do
    IO.println (String.intercalate " " (s.map showColor))

</pre>
</div>
</div>
</div>
<div id="outline-container-org19a3ee0" class="outline-2">
<h2 id="org19a3ee0">Haskell</h2>
<div class="outline-text-2" id="text-org19a3ee0">
<div class="org-src-container">
<pre class="src src-haskell">module Main where

data Color = R | G | B | E
  deriving (Eq, Show)

data Counts = Counts
  { cr :: Int
  , cg :: Int
  , cb :: Int
  , ce :: Int
  } deriving (Show)

countsZero :: Counts -&gt; Bool
countsZero (Counts r g b e) = r == 0 &amp;&amp; g == 0 &amp;&amp; b == 0 &amp;&amp; e == 0

decCount :: Counts -&gt; Color -&gt; Counts
decCount c col = case col of
  R -&gt; c { cr = cr c - 1 }
  G -&gt; c { cg = cg c - 1 }
  B -&gt; c { cb = cb c - 1 }
  E -&gt; c { ce = ce c - 1 }

allowed :: Counts -&gt; Maybe Color -&gt; [Color]
allowed counts prev = filter ok [R, G, B, E]
  where
    avail c = case c of
      R -&gt; cr counts
      G -&gt; cg counts
      B -&gt; cb counts
      E -&gt; ce counts
    ok c =
      avail c &gt; 0 &amp;&amp;
      case prev of
        Nothing -&gt; True
        Just p  -&gt; (p /= c) || (c == E)  -- empties may repeat; colored must differ

-- build positions: rem = remaining slots to fill
build :: Int -&gt; Maybe Color -&gt; Counts -&gt; [[Color]]
build 0 _ counts = if countsZero counts then [[]] else []
build rem prev counts =
  concatMap extend (allowed counts prev)
  where
    extend c = map (c :) (build (rem - 1) (Just c) (decCount counts c))

showColor :: Color -&gt; String
showColor R = "R"
showColor G = "G"
showColor B = "B"
showColor E = "."

main :: IO ()
main = do
  let initial = Counts { cr = 2, cg = 2, cb = 2, ce = 3 }
      solutions = build 9 Nothing initial
  putStrLn $ "Found " ++ show (length solutions) ++ " solutions ('.' = empty)"
  mapM_ (putStrLn . unwords . map showColor) solutions

</pre>
</div>
</div>
</div>
<div id="outline-container-org66bccab" class="outline-2">
<h2 id="org66bccab">Rust</h2>
<div class="outline-text-2" id="text-org66bccab">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #10b1fe;">use</span> <span style="color: #9f7efe;">std</span>::fmt;

<span style="color: #7a82da; font-weight: bold;">#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span>
<span style="color: #10b1fe;">enum</span> <span style="color: #ff6480;">Color</span> {
    <span style="color: #ff6480;">R</span>,
    <span style="color: #ff6480;">G</span>,
    <span style="color: #ff6480;">B</span>,
    <span style="color: #ff6480;">E</span>,
}

<span style="color: #10b1fe;">impl</span> <span style="color: #9f7efe;">fmt</span>::<span style="color: #ff6480;">Display</span> <span style="color: #10b1fe;">for</span> <span style="color: #ff6480;">Color</span> {
    <span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">fmt</span>(<span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">self</span>, <span style="color: #8bcdef;">f</span>: <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> <span style="color: #9f7efe;">fmt</span>::<span style="color: #ff6480;">Formatter</span>&lt;'<span style="color: #8bcdef;">_</span>&gt;) -&gt; <span style="color: #9f7efe;">fmt</span>::<span style="color: #ff6480;">Result</span> {
        <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">s</span> = <span style="color: #10b1fe;">match</span> <span style="color: #10b1fe;">self</span> {
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span> =&gt; <span style="color: #f9c859;">"R"</span>,
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span> =&gt; <span style="color: #f9c859;">"G"</span>,
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span> =&gt; <span style="color: #f9c859;">"B"</span>,
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span> =&gt; <span style="color: #f9c859;">"."</span>,
        };
        <span style="color: #3fc56b;">write!</span>(f, <span style="color: #f9c859;">"</span><span style="color: #f9c859; font-style: italic;">{}</span><span style="color: #f9c859;">"</span>, s)
    }
}

<span style="color: #7a82da; font-weight: bold;">#[derive(Clone, Copy, Debug)]</span>
<span style="color: #10b1fe;">struct</span> <span style="color: #ff6480;">Counts</span> {
    <span style="color: #8bcdef;">r</span>: <span style="color: #ff6480;">u32</span>,
    <span style="color: #8bcdef;">g</span>: <span style="color: #ff6480;">u32</span>,
    <span style="color: #8bcdef;">b</span>: <span style="color: #ff6480;">u32</span>,
    <span style="color: #8bcdef;">e</span>: <span style="color: #ff6480;">u32</span>,
}

<span style="color: #10b1fe;">impl</span> <span style="color: #ff6480;">Counts</span> {
    <span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">zero</span>(<span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">self</span>) -&gt; <span style="color: #ff6480;">bool</span> {
        <span style="color: #10b1fe;">self</span>.r == <span style="color: #ff78f8; font-weight: bold;">0</span> &amp;&amp; <span style="color: #10b1fe;">self</span>.g == <span style="color: #ff78f8; font-weight: bold;">0</span> &amp;&amp; <span style="color: #10b1fe;">self</span>.b == <span style="color: #ff78f8; font-weight: bold;">0</span> &amp;&amp; <span style="color: #10b1fe;">self</span>.e == <span style="color: #ff78f8; font-weight: bold;">0</span>
    }
}

<span style="color: #f9c859;">/// decrement one count of `col` (caller must ensure availability &gt; 0)</span>
<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">dec_count</span>(<span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">c</span>: <span style="color: #ff6480;">Counts</span>, <span style="color: #8bcdef;">col</span>: <span style="color: #ff6480;">Color</span>) -&gt; <span style="color: #ff6480;">Counts</span> {
    <span style="color: #10b1fe;">match</span> col {
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span> =&gt; c.r -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span> =&gt; c.g -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span> =&gt; c.b -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span> =&gt; c.e -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
    }
    c
}

<span style="color: #f9c859;">/// allowed choices given remaining counts and previous placed color</span>
<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">allowed</span>(<span style="color: #8bcdef;">counts</span>: <span style="color: #ff6480;">Counts</span>, <span style="color: #8bcdef;">prev</span>: <span style="color: #ff6480;">Option</span>&lt;<span style="color: #ff6480;">Color</span>&gt;) -&gt; <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt; {
    <span style="color: #10b1fe;">let</span> <span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">v</span> = <span style="color: #ff6480;">Vec</span>::new();
    <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">ok</span> = |<span style="color: #8bcdef;">col</span>: <span style="color: #ff6480;">Color</span>, <span style="color: #8bcdef;">avail</span>: <span style="color: #ff6480;">u32</span>| -&gt; <span style="color: #ff6480;">bool</span> {
        <span style="color: #10b1fe;">if</span> avail == <span style="color: #ff78f8; font-weight: bold;">0</span> {
            <span style="color: #10b1fe;">return</span> <span style="color: #10b1fe;">false</span>;
        }
        <span style="color: #10b1fe;">match</span> prev {
            <span style="color: #ff6480;">None</span> =&gt; <span style="color: #10b1fe;">true</span>,
            <span style="color: #ff6480;">Some</span>(p) =&gt; p != col || col == <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span>, <span style="color: #7a808b;">// </span><span style="color: #7a808b;">empties may repeat; colored must differ</span>
        }
    };
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span>, counts.r) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span>);
    }
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span>, counts.g) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span>);
    }
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span>, counts.b) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span>);
    }
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span>, counts.e) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span>);
    }
    v
}

<span style="color: #f9c859;">/// backtracking builder</span>
<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">backtrack</span>(
    <span style="color: #8bcdef;">rem</span>: <span style="color: #ff6480;">usize</span>,
    <span style="color: #8bcdef;">prev</span>: <span style="color: #ff6480;">Option</span>&lt;<span style="color: #ff6480;">Color</span>&gt;,
    <span style="color: #8bcdef;">counts</span>: <span style="color: #ff6480;">Counts</span>,
    <span style="color: #8bcdef;">current</span>: <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt;,
    <span style="color: #8bcdef;">solutions</span>: <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt;&gt;,
) {
    <span style="color: #10b1fe;">if</span> rem == <span style="color: #ff78f8; font-weight: bold;">0</span> {
        <span style="color: #10b1fe;">if</span> counts.zero() {
            solutions.push(current.clone());
        }
        <span style="color: #10b1fe;">return</span>;
    }

    <span style="color: #10b1fe;">for</span> <span style="color: #8bcdef;">col</span> <span style="color: #10b1fe;">in</span> allowed(counts, prev) {
        <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">counts_next</span> = dec_count(counts, col);
        current.push(col);
        backtrack(rem - <span style="color: #ff78f8; font-weight: bold;">1</span>, <span style="color: #ff6480;">Some</span>(col), counts_next, current, solutions);
        current.pop();
    }
}

<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">main</span>() {
    <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">initial</span> = <span style="color: #ff6480;">Counts</span> {
        <span style="color: #8bcdef;">r</span>: <span style="color: #ff78f8; font-weight: bold;">2</span>,
        <span style="color: #8bcdef;">g</span>: <span style="color: #ff78f8; font-weight: bold;">2</span>,
        <span style="color: #8bcdef;">b</span>: <span style="color: #ff78f8; font-weight: bold;">2</span>,
        <span style="color: #8bcdef;">e</span>: <span style="color: #ff78f8; font-weight: bold;">3</span>,
    };
    <span style="color: #10b1fe;">let</span> <span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">solutions</span>: <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt;&gt; = <span style="color: #ff6480;">Vec</span>::new();
    <span style="color: #10b1fe;">let</span> <span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">current</span>: <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt; = <span style="color: #ff6480;">Vec</span>::with_capacity(<span style="color: #ff78f8; font-weight: bold;">9</span>);
    backtrack(<span style="color: #ff78f8; font-weight: bold;">9</span>, <span style="color: #ff6480;">None</span>, initial, <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> current, <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> solutions);

    <span style="color: #3fc56b;">println!</span>(
        <span style="color: #f9c859;">"Found </span><span style="color: #f9c859; font-style: italic;">{}</span><span style="color: #f9c859;"> solutions (each printed as a 9-length sequence; '.' = empty)"</span>,
        solutions.len()
    );
    solutions.iter().for_each(|s| {
        <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">line</span> = s.iter()
                .map(|c| c.to_string())
                .collect::&lt;<span style="color: #ff6480;">Vec</span>&lt;_&gt;&gt;()
                .join(<span style="color: #f9c859;">" "</span>);
        <span style="color: #3fc56b;">println!</span>(<span style="color: #f9c859;">"</span><span style="color: #f9c859; font-style: italic;">{}</span><span style="color: #f9c859;">"</span>, line);
    });

}

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: emporas</p>
<p class="date">Created: 2025-09-28 Sun 02:38</p>
</div>
</body>
</html>
