<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-09-28 Sun 02:38 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Η Γλώσσα Κατώτερου Επιπέδου</title>
<meta name="author" content="emporas" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Η Γλώσσα Κατώτερου Επιπέδου</h1>
<div id="table-of-contents" role="doc-toc">
<h1><a accesskey="H" href="../index.html"> Αρχική Σελίδα </a></h1><h2>Πίνακας Περιεχομένων</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org19c1702">Μαθηματικά και διατύπωση του προβλήματος</a>
<ul>
<li><a href="#org10798ee">Σημειογραφία και ιδέα</a></li>
<li><a href="#org0cf1ecf">Διάταξη συμπερίληψης–αποκλεισμού</a>
<ul>
<li><a href="#org1b1691f">Συνολικό (χωρίς περιορισμούς)</a></li>
<li><a href="#orgb077630">Ένα χρώμα σε γειτνίαση (π.χ. (A<sub>R</sub>))</a></li>
<li><a href="#orgd882792">Δύο χρώματα σε γειτνίαση (π.χ. (A<sub>R&cap;</sub> A<sub>G</sub>))</a></li>
<li><a href="#orgab2edc1">Και τα τρία χρώματα σε γειτνίαση ((A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>))</a></li>
</ul>
</li>
<li><a href="#org1ef6a6e">Συνδυάζοντας τα παραπάνω</a></li>
</ul>
</li>
<li><a href="#org174063d">Lean</a></li>
<li><a href="#orgf81837d">Haskell</a></li>
<li><a href="#orgb91de51">Rust</a></li>
</ul>
</div>
</div>
<p>
Ας συγκρίνουμε τις διαφορετικές υλοποιήσεις ενός απλού προβλήματος σε τρεις γλώσσες προγραμματισμού. Και οι τρεις έχουν μερικά κοινά χαρακτηριστικά.
</p>

<ul class="org-ul">
<li>Εξαντλητική απαρίθμηση τύπων</li>
<li>Χωρίς null/nil</li>
<li>Αλγεβρικοί τύποι δεδομένων</li>
</ul>

<p>
Η υλοποίηση σε Rust δεν είναι ιδανική, αλλά την άφησα έτσι ώστε να μοιάζει όσο το δυνατόν περισσότερο με τις άλλες υλοποιήσεις. Επίσης, η Rust δεν έχει αναδρομή.
</p>

<p>
Οι μαθηματικοί τύποι σε μερικά σημεία δεν μπορούν να αντιγραφούν, δεν αναγνωρίζονται ως μαθηματική TeX σύνταξη. Δεν μπορώ να καταλάβω γιατί, αλλά πρώτη φορά που έγραψα μαθηματικά χρησιμοποιώντας TeX.
</p>
<div id="outline-container-org19c1702" class="outline-2">
<h2 id="org19c1702">Μαθηματικά και διατύπωση του προβλήματος</h2>
<div class="outline-text-2" id="text-org19c1702">
<p>
<b>Καταμέτρηση τοποθετήσεων — 6 έγχρωμοι κύβοι σε 9 θέσεις</b>
</p>

<p>
Τοποθετούμε έξι έγχρωμους κύβους — δύο κόκκινους (R), δύο πράσινους (G), δύο μπλε (B) — σε εννέα επισημασμένες θέσεις (θέσεις σε σειρά). Οι υπόλοιπες τρεις θέσεις είναι κενές (συμβολίζουμε το κενό με E ή &ldquo;.&rdquo;).
</p>

<p>
Περιορισμός: <b><b>Δεν επιτρέπεται να εμφανιστούν δύο διπλανά έγχρωμα κύβοι του ίδιου χρώματος</b></b>. Οι κενές θέσεις μπορούν να είναι διπλανές με οτιδήποτε (συμπεριλαμβανομένων άλλων κενών και γειτόνων ίδιου χρώματος).
</p>

<p>
Ερωτάμε: πόσες διακριτές διατάξεις (ακολουθίες μήκους 9 του πολυσυνόλου ({R<sup>2,G</sup><sup>2,B</sup><sup>2,E</sup><sup>3</sup>})) ικανοποιούν τον περιορισμό της γειτνίασης;
</p>
</div>
<div id="outline-container-org10798ee" class="outline-3">
<h3 id="org10798ee">Σημειογραφία και ιδέα</h3>
<div class="outline-text-3" id="text-org10798ee">
<p>
Έστω το πολυσύνολο ({R,R,G,G,B,B,E,E,E}). Χωρίς περιορισμούς γειτνίασης, ο αριθμός των διακριτών ακολουθιών δίνεται από τον πολυωνυμικό (multinomial) τύπο
\[
N_{\text{total}}=\frac{9!}{2!,2!,2!,3!}.
\]
</p>

<p>
Έστω για χρώμα \(X\in{R,G,B}\) το γεγονός \(A_X\) ότι «οι δύο κύβοι \(X\) είναι γειτονικοί κάπου στην ακολουθία». Εφόσον κάθε χρώμα εμφανίζεται ακριβώς δύο φορές, το \(A_X\) είναι ισοδύναμο με το ότι οι δύο κύβοι \(X\) σχηματίζουν ένα ενιαίο μπλοκ \(XX\).
</p>

<p>
Θέλουμε ακολουθίες που αποφεύγουν τα τρία γεγονότα \(A_R,A_G,A_B\). Θα τα μετρήσουμε χρησιμοποιώντας τη μέθοδο συμπερίληψης–αποκλεισμού.
</p>
</div>
</div>
<div id="outline-container-org0cf1ecf" class="outline-3">
<h3 id="org0cf1ecf">Διάταξη συμπερίληψης–αποκλεισμού</h3>
<div class="outline-text-3" id="text-org0cf1ecf">
<p>
Με συμπερίληψη–αποκλεισμό,
</p>

<p>
N<sub>good</sub> = N<sub>total</sub> - &sum;<sub>X</sub> N(A<sub>X</sub>) + &sum;<sub>X&lt;Y</sub> N(A<sub>X&cap;</sub> A<sub>Y</sub>) - N(A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>).
</p>

<p>
N<sub>good</sub> = N<sub>total</sub> - &sum;<sub>X&isin;\{R,G,B\}</sub> N(A<sub>X</sub>) + &sum;<sub>X&lt;Y</sub> N(A<sub>X&cap;</sub> A<sub>Y</sub>) - N(A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>).
</p>

<p>
Υπολογίζουμε κάθε όρο αντικαθιστώντας κάθε διπλό ζεύγος \(XX\) με ένα ενιαίο μπλοκ και μετρώντας τις διατάξεις του προκύπτοντος πολυσυνόλου.
</p>
</div>
<div id="outline-container-org1b1691f" class="outline-4">
<h4 id="org1b1691f">Συνολικό (χωρίς περιορισμούς)</h4>
<div class="outline-text-4" id="text-org1b1691f">
<p>
\[
N_{\text{total}}=\frac{9!}{2!\,2!\,2!\,3!}.
\]
</p>

<p>
Υπολογίζουμε ρητά τις παραγοντικές και τους παρονομαστές:
</p>
\begin{align*}
9!&=362\,880,\\
2!\,2!\,2!\,3!&=2\cdot2\cdot2\cdot6=48,\\
N_{\text{total}}&=\frac{362\,880}{48}=7\,560.
\end{align*}
</div>
</div>
<div id="outline-container-orgb077630" class="outline-4">
<h4 id="orgb077630">Ένα χρώμα σε γειτνίαση (π.χ. (A<sub>R</sub>))</h4>
<div class="outline-text-4" id="text-orgb077630">
<p>
Θεωρούμε τους δύο κύβους (R) ως ένα ενιαίο μπλοκ (RR). Το υπόλοιπο πολυσύνολο είναι \(\{RR, G,G, B,B, E,E,E\}\) μεγέθους 8 με πολλαπλότητες \(G:2, B:2, E:3\). Συνεπώς
\[
N(A_R)=\frac{8!}{2!,2!,3!}.
\]
Υπολογίζουμε:
</p>
\begin{align*}
8!&=40,320,\
2!,2!,3!&=2\cdot2\cdot6=24,\\
N(A_R)&=\frac{40,320}{24}=1,680.
\end{align*}

<p>
Κατά συμμετρία η ίδια τιμή ισχύει για \(N(A_G)\) και \(N(A_B)\). Επομένως
\[
\sum_X N(A_X)=3\cdot1,680=5,040.
\]
</p>
</div>
</div>
<div id="outline-container-orgd882792" class="outline-4">
<h4 id="orgd882792">Δύο χρώματα σε γειτνίαση (π.χ. (A<sub>R&cap;</sub> A<sub>G</sub>))</h4>
<div class="outline-text-4" id="text-orgd882792">
<p>
Θεωρούμε (RR) και (GG) ως δύο μπλοκ. Το υπόλοιπο πολυσύνολο είναι ({RR,GG,B,B,E,E,E}) μεγέθους 7 με πολλαπλότητες \(B:2, E:3\). Έτσι
\[
N(A_R\cap A_G)=\frac{7!}{2!,3!}.
\]
Υπολογίζουμε:
</p>
\begin{align*}
7!&=5,040,\
2!,3!&=2\cdot6=12,\
N(A_R\cap A_G)&=\frac{5,040}{12}=420.
\end{align*}

<p>
Υπάρχουν \(\binom{3}{2}=3\) ανεξάρτητα ζεύγη χρωμάτων, οπότε
\[
\sum_{X\lt Y} N(A_X\cap A_Y) = 3\cdot420 = 1260.
\]
</p>
</div>
</div>
<div id="outline-container-orgab2edc1" class="outline-4">
<h4 id="orgab2edc1">Και τα τρία χρώματα σε γειτνίαση ((A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>))</h4>
<div class="outline-text-4" id="text-orgab2edc1">
<p>
Θεωρούμε (RR,GG,BB) ως τρία μπλοκ. Το υπόλοιπο πολυσύνολο είναι ({RR,GG,BB,E,E,E}) μεγέθους 6 με πολλαπλότητα (E:3). Επομένως
</p>

<p>
\[
N(A_R\cap A_G\cap A_B)=\frac{6!}{3!}.
\]
Υπολογίζουμε:
</p>
\begin{align*}
6!&=720,\\
3!&=6,\\
N(A_R\cap A_G\cap A_B)&=\frac{720}{6}=120.
\end{align*}
</div>
</div>
</div>
<div id="outline-container-org1ef6a6e" class="outline-3">
<h3 id="org1ef6a6e">Συνδυάζοντας τα παραπάνω</h3>
<div class="outline-text-3" id="text-org1ef6a6e">
<p>
Εφαρμόζοντας τη μέθοδο συμπερίληψης–αποκλεισμού:
</p>

<p>
N<sub>good</sub>
= N<sub>total</sub> - &sum;<sub>X</sub> N(A<sub>X</sub>) + &sum;<sub>X&lt;Y</sub> N(A<sub>X&cap;</sub> A<sub>Y</sub>) - N(A<sub>R&cap;</sub> A<sub>G&cap;</sub> A<sub>B</sub>)
= 7560 - 5040 + 1260 - 120 = 3660.
</p>

<p>
Επομένως υπάρχουν \(\boxed{3,660}\) επιτρεπτές διατάξεις.
</p>
</div>
</div>
</div>
<div id="outline-container-org174063d" class="outline-2">
<h2 id="org174063d">Lean</h2>
<div class="outline-text-2" id="text-org174063d">
<div class="org-src-container">
<pre class="src src-haskell">inductive Color where
  | R | G | B | E
  deriving Repr, DecidableEq

structure Counts where
  r : Nat
  g : Nat
  b : Nat
  e : Nat
  deriving Repr

def countsZero (c : Counts) : Bool :=
  c.r == 0 &amp;&amp; c.g == 0 &amp;&amp; c.b == 0 &amp;&amp; c.e == 0

def decCount (c : Counts) (col : Color) : Counts :=
  match col with
  | Color.R =&gt; { c with r := c.r - 1 }
  | Color.G =&gt; { c with g := c.g - 1 }
  | Color.B =&gt; { c with b := c.b - 1 }
  | Color.E =&gt; { c with e := c.e - 1 }

-- allowed choices given remaining counts and previous placed color
def allowed (counts : Counts) (prev : Option Color) : List Color :=
  let ok (col : Color) (avail : Nat) : Bool :=
    avail &gt; 0 &amp;&amp;
    match prev with
    | none =&gt; true
    | some p =&gt; (p != col) || (col == Color.E) -- empties may repeat; colored must differ
  ([Color.R, Color.G, Color.B, Color.E]).filter fun col =&gt;
    match col with
    | Color.R =&gt; ok Color.R counts.r
    | Color.G =&gt; ok Color.G counts.g
    | Color.B =&gt; ok Color.B counts.b
    | Color.E =&gt; ok Color.E counts.e

partial def build (rem : Nat) (prev : Option Color) (counts : Counts) : List (List Color) :=
  if rem == 0 then
    if countsZero counts then [ [] ] else []
  else
    let choices := allowed counts prev
    -- avoid using `List.bind` in case of name-resolution differences;
    -- build result by folding over choices and appending mapped tails
    choices.foldl (fun acc c =&gt;
      let counts' := decCount counts c
      let tails := build (rem - 1) (some c) counts'
      acc ++ (tails.map fun t =&gt; c :: t)
    ) []

def showColor : Color -&gt; String
  | Color.R =&gt; "R"
  | Color.G =&gt; "G"
  | Color.B =&gt; "B"
  | Color.E =&gt; "."

def main : IO Unit := do
  let initial : Counts := { r := 2, g := 2, b := 2, e := 3 }
  let solutions := build 9 none initial
  IO.println s!"Found {solutions.length} solutions (each printed as a 9-length sequence; '.' = empty)"
  for s in solutions do
    IO.println (String.intercalate " " (s.map showColor))

</pre>
</div>
</div>
</div>
<div id="outline-container-orgf81837d" class="outline-2">
<h2 id="orgf81837d">Haskell</h2>
<div class="outline-text-2" id="text-orgf81837d">
<div class="org-src-container">
<pre class="src src-haskell">module Main where

data Color = R | G | B | E
  deriving (Eq, Show)

data Counts = Counts
  { cr :: Int
  , cg :: Int
  , cb :: Int
  , ce :: Int
  } deriving (Show)

countsZero :: Counts -&gt; Bool
countsZero (Counts r g b e) = r == 0 &amp;&amp; g == 0 &amp;&amp; b == 0 &amp;&amp; e == 0

decCount :: Counts -&gt; Color -&gt; Counts
decCount c col = case col of
  R -&gt; c { cr = cr c - 1 }
  G -&gt; c { cg = cg c - 1 }
  B -&gt; c { cb = cb c - 1 }
  E -&gt; c { ce = ce c - 1 }

allowed :: Counts -&gt; Maybe Color -&gt; [Color]
allowed counts prev = filter ok [R, G, B, E]
  where
    avail c = case c of
      R -&gt; cr counts
      G -&gt; cg counts
      B -&gt; cb counts
      E -&gt; ce counts
    ok c =
      avail c &gt; 0 &amp;&amp;
      case prev of
        Nothing -&gt; True
        Just p  -&gt; (p /= c) || (c == E)  -- empties may repeat; colored must differ

-- build positions: rem = remaining slots to fill
build :: Int -&gt; Maybe Color -&gt; Counts -&gt; [[Color]]
build 0 _ counts = if countsZero counts then [[]] else []
build rem prev counts =
  concatMap extend (allowed counts prev)
  where
    extend c = map (c :) (build (rem - 1) (Just c) (decCount counts c))

showColor :: Color -&gt; String
showColor R = "R"
showColor G = "G"
showColor B = "B"
showColor E = "."

main :: IO ()
main = do
  let initial = Counts { cr = 2, cg = 2, cb = 2, ce = 3 }
      solutions = build 9 Nothing initial
  putStrLn $ "Found " ++ show (length solutions) ++ " solutions ('.' = empty)"
  mapM_ (putStrLn . unwords . map showColor) solutions

</pre>
</div>
</div>
</div>
<div id="outline-container-orgb91de51" class="outline-2">
<h2 id="orgb91de51">Rust</h2>
<div class="outline-text-2" id="text-orgb91de51">
<div class="org-src-container">
<pre class="src src-rust"><span style="color: #10b1fe;">use</span> <span style="color: #9f7efe;">std</span>::fmt;

<span style="color: #7a82da; font-weight: bold;">#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span>
<span style="color: #10b1fe;">enum</span> <span style="color: #ff6480;">Color</span> {
    <span style="color: #ff6480;">R</span>,
    <span style="color: #ff6480;">G</span>,
    <span style="color: #ff6480;">B</span>,
    <span style="color: #ff6480;">E</span>,
}

<span style="color: #10b1fe;">impl</span> <span style="color: #9f7efe;">fmt</span>::<span style="color: #ff6480;">Display</span> <span style="color: #10b1fe;">for</span> <span style="color: #ff6480;">Color</span> {
    <span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">fmt</span>(<span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">self</span>, <span style="color: #8bcdef;">f</span>: <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> <span style="color: #9f7efe;">fmt</span>::<span style="color: #ff6480;">Formatter</span>&lt;'<span style="color: #8bcdef;">_</span>&gt;) -&gt; <span style="color: #9f7efe;">fmt</span>::<span style="color: #ff6480;">Result</span> {
        <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">s</span> = <span style="color: #10b1fe;">match</span> <span style="color: #10b1fe;">self</span> {
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span> =&gt; <span style="color: #f9c859;">"R"</span>,
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span> =&gt; <span style="color: #f9c859;">"G"</span>,
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span> =&gt; <span style="color: #f9c859;">"B"</span>,
            <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span> =&gt; <span style="color: #f9c859;">"."</span>,
        };
        <span style="color: #3fc56b;">write!</span>(f, <span style="color: #f9c859;">"</span><span style="color: #f9c859; font-style: italic;">{}</span><span style="color: #f9c859;">"</span>, s)
    }
}

<span style="color: #7a82da; font-weight: bold;">#[derive(Clone, Copy, Debug)]</span>
<span style="color: #10b1fe;">struct</span> <span style="color: #ff6480;">Counts</span> {
    <span style="color: #8bcdef;">r</span>: <span style="color: #ff6480;">u32</span>,
    <span style="color: #8bcdef;">g</span>: <span style="color: #ff6480;">u32</span>,
    <span style="color: #8bcdef;">b</span>: <span style="color: #ff6480;">u32</span>,
    <span style="color: #8bcdef;">e</span>: <span style="color: #ff6480;">u32</span>,
}

<span style="color: #10b1fe;">impl</span> <span style="color: #ff6480;">Counts</span> {
    <span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">zero</span>(<span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">self</span>) -&gt; <span style="color: #ff6480;">bool</span> {
        <span style="color: #10b1fe;">self</span>.r == <span style="color: #ff78f8; font-weight: bold;">0</span> &amp;&amp; <span style="color: #10b1fe;">self</span>.g == <span style="color: #ff78f8; font-weight: bold;">0</span> &amp;&amp; <span style="color: #10b1fe;">self</span>.b == <span style="color: #ff78f8; font-weight: bold;">0</span> &amp;&amp; <span style="color: #10b1fe;">self</span>.e == <span style="color: #ff78f8; font-weight: bold;">0</span>
    }
}

<span style="color: #f9c859;">/// decrement one count of `col` (caller must ensure availability &gt; 0)</span>
<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">dec_count</span>(<span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">c</span>: <span style="color: #ff6480;">Counts</span>, <span style="color: #8bcdef;">col</span>: <span style="color: #ff6480;">Color</span>) -&gt; <span style="color: #ff6480;">Counts</span> {
    <span style="color: #10b1fe;">match</span> col {
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span> =&gt; c.r -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span> =&gt; c.g -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span> =&gt; c.b -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
        <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span> =&gt; c.e -= <span style="color: #ff78f8; font-weight: bold;">1</span>,
    }
    c
}

<span style="color: #f9c859;">/// allowed choices given remaining counts and previous placed color</span>
<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">allowed</span>(<span style="color: #8bcdef;">counts</span>: <span style="color: #ff6480;">Counts</span>, <span style="color: #8bcdef;">prev</span>: <span style="color: #ff6480;">Option</span>&lt;<span style="color: #ff6480;">Color</span>&gt;) -&gt; <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt; {
    <span style="color: #10b1fe;">let</span> <span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">v</span> = <span style="color: #ff6480;">Vec</span>::new();
    <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">ok</span> = |<span style="color: #8bcdef;">col</span>: <span style="color: #ff6480;">Color</span>, <span style="color: #8bcdef;">avail</span>: <span style="color: #ff6480;">u32</span>| -&gt; <span style="color: #ff6480;">bool</span> {
        <span style="color: #10b1fe;">if</span> avail == <span style="color: #ff78f8; font-weight: bold;">0</span> {
            <span style="color: #10b1fe;">return</span> <span style="color: #10b1fe;">false</span>;
        }
        <span style="color: #10b1fe;">match</span> prev {
            <span style="color: #ff6480;">None</span> =&gt; <span style="color: #10b1fe;">true</span>,
            <span style="color: #ff6480;">Some</span>(p) =&gt; p != col || col == <span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span>, <span style="color: #7a808b;">// </span><span style="color: #7a808b;">empties may repeat; colored must differ</span>
        }
    };
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span>, counts.r) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">R</span>);
    }
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span>, counts.g) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">G</span>);
    }
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span>, counts.b) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">B</span>);
    }
    <span style="color: #10b1fe;">if</span> ok(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span>, counts.e) {
        v.push(<span style="color: #ff6480;">Color</span>::<span style="color: #ff6480;">E</span>);
    }
    v
}

<span style="color: #f9c859;">/// backtracking builder</span>
<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">backtrack</span>(
    <span style="color: #8bcdef;">rem</span>: <span style="color: #ff6480;">usize</span>,
    <span style="color: #8bcdef;">prev</span>: <span style="color: #ff6480;">Option</span>&lt;<span style="color: #ff6480;">Color</span>&gt;,
    <span style="color: #8bcdef;">counts</span>: <span style="color: #ff6480;">Counts</span>,
    <span style="color: #8bcdef;">current</span>: <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt;,
    <span style="color: #8bcdef;">solutions</span>: <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt;&gt;,
) {
    <span style="color: #10b1fe;">if</span> rem == <span style="color: #ff78f8; font-weight: bold;">0</span> {
        <span style="color: #10b1fe;">if</span> counts.zero() {
            solutions.push(current.clone());
        }
        <span style="color: #10b1fe;">return</span>;
    }

    <span style="color: #10b1fe;">for</span> <span style="color: #8bcdef;">col</span> <span style="color: #10b1fe;">in</span> allowed(counts, prev) {
        <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">counts_next</span> = dec_count(counts, col);
        current.push(col);
        backtrack(rem - <span style="color: #ff78f8; font-weight: bold;">1</span>, <span style="color: #ff6480;">Some</span>(col), counts_next, current, solutions);
        current.pop();
    }
}

<span style="color: #10b1fe;">fn</span> <span style="color: #3fc56b;">main</span>() {
    <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">initial</span> = <span style="color: #ff6480;">Counts</span> {
        <span style="color: #8bcdef;">r</span>: <span style="color: #ff78f8; font-weight: bold;">2</span>,
        <span style="color: #8bcdef;">g</span>: <span style="color: #ff78f8; font-weight: bold;">2</span>,
        <span style="color: #8bcdef;">b</span>: <span style="color: #ff78f8; font-weight: bold;">2</span>,
        <span style="color: #8bcdef;">e</span>: <span style="color: #ff78f8; font-weight: bold;">3</span>,
    };
    <span style="color: #10b1fe;">let</span> <span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">solutions</span>: <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt;&gt; = <span style="color: #ff6480;">Vec</span>::new();
    <span style="color: #10b1fe;">let</span> <span style="color: #10b1fe;">mut</span> <span style="color: #8bcdef;">current</span>: <span style="color: #ff6480;">Vec</span>&lt;<span style="color: #ff6480;">Color</span>&gt; = <span style="color: #ff6480;">Vec</span>::with_capacity(<span style="color: #ff78f8; font-weight: bold;">9</span>);
    backtrack(<span style="color: #ff78f8; font-weight: bold;">9</span>, <span style="color: #ff6480;">None</span>, initial, <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> current, <span style="color: #abb2bf; background-color: #282c34;">&amp;</span><span style="color: #10b1fe;">mut</span> solutions);

    <span style="color: #3fc56b;">println!</span>(
        <span style="color: #f9c859;">"Found </span><span style="color: #f9c859; font-style: italic;">{}</span><span style="color: #f9c859;"> solutions (each printed as a 9-length sequence; '.' = empty)"</span>,
        solutions.len()
    );
    solutions.iter().for_each(|s| {
        <span style="color: #10b1fe;">let</span> <span style="color: #8bcdef;">line</span> = s.iter()
                .map(|c| c.to_string())
                .collect::&lt;<span style="color: #ff6480;">Vec</span>&lt;_&gt;&gt;()
                .join(<span style="color: #f9c859;">" "</span>);
        <span style="color: #3fc56b;">println!</span>(<span style="color: #f9c859;">"</span><span style="color: #f9c859; font-style: italic;">{}</span><span style="color: #f9c859;">"</span>, line);
    });

}

</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: emporas</p>
<p class="date">Created: 2025-09-28 Sun 02:38</p>
</div>
</body>
</html>
